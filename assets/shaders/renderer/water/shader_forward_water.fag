//a shader of extraordinary walteriness
#version 330 core

in VS_OUT{
    vec2 texCoords;
    vec3 fragPos;
    vec3 fragPosViewSpace;
    mat3 tbn;
}fs_in;

out vec4 fragColour;

uniform vec3 cameraPos;

//yeah
uniform vec3 waterColourShallow;
uniform vec3 waterColourDeep;
const float shallowStart=10;
const float shallowHelper=0.1;

uniform mat4 projectionInverse;//to get the view space position of the walter floor

//textures
uniform sampler2D texture_normal;
uniform sampler2D texture_dudv;
uniform sampler2D texture_depth_geometry;
uniform sampler2D texture_depth_shadow;
uniform float uvOffset;

//depth things
uniform float onePerScreenWidth;
uniform float onePerScreenHeight;
uniform float projectionFar;
uniform float projectionNear;

//lights
struct light{
    vec3 colour;
    vec3 position;
    vec3 attenuation;//x: intensity, y: linear, z: quadratic
};

uniform light sun;

uniform mat4 shadow_lightMatrix;
uniform int shadowOn;
const float shadowBias=0.003;
uniform float shadowStart;
uniform float shadowEnd;
uniform float shadowHelper;// 1/(shadowEnd-shadowStart)

//fog
uniform float fogStart;
uniform float fogEnd;
uniform float fogHelper;

float linearizeDepth(float);

void main()
{
    vec2 screenUV=vec2(gl_FragCoord.x*onePerScreenWidth, gl_FragCoord.y*onePerScreenHeight);
    float distanceFromEye=length(fs_in.fragPos-cameraPos);
    vec3 viewDirection=normalize(cameraPos-fs_in.fragPos);

    //getting water depth
    //float depth=linearizeDepth(texture(texture_depth_geometry, screenUV).r)-linearizeDepth(gl_FragCoord.z);

	vec4 tempPos = projectionInverse * (vec4(screenUV, texture(texture_depth_geometry, screenUV).r, 1)* 2 - 1);
	vec3 waterFloorViewSpace = tempPos.xyz / tempPos.w;

    float depth=length(waterFloorViewSpace-fs_in.fragPosViewSpace);
    if(depth<shallowStart)
        depth*=shallowHelper;
    if(depth>1)
        depth=1;

    //getting walter tint
    vec3 waterColour=mix(waterColourShallow, waterColourDeep, depth);

    //get distorted uv
    vec2 distortedUV=fs_in.texCoords+(2*texture(texture_dudv, vec2(fs_in.texCoords.x+0.5*uvOffset, fs_in.texCoords.y+uvOffset)).rg-1)*0.03;
    distortedUV=vec2(distortedUV.x+uvOffset, distortedUV.y);
    
    //get normal
    vec3 normal=normalize(fs_in.tbn*(2*texture(texture_normal, distortedUV).rgb-1));

    //lighting calculations
    vec3 lighting_sum=vec3(0);
    vec3 ambient, diffuse, specular;
    vec3 halfway;

    //sun ambient
	ambient = 0.3*sun.attenuation.x*sun.colour*waterColour;
	//diffuse
	diffuse = max(dot(normal, sun.position), 0.0) * waterColour * sun.colour*sun.attenuation.x;

	//sun specular
	halfway = normalize(sun.position + viewDirection);  
	specular = sun.attenuation.x*sun.colour *pow(max(dot(normal, halfway), 0.0), 128.0);

    //sun shadow
	float oneMinusShadowStrength=1;
	if(shadowOn!=0)
	{
		vec4 shadowPos=shadow_lightMatrix*vec4(fs_in.fragPosViewSpace, 1);
		shadowPos.xyz/=shadowPos.w;
		shadowPos=0.5*shadowPos+0.5;
		float shadowDepth=texture(texture_depth_shadow, shadowPos.xy).r;


		if(shadowPos.x<=1&&shadowPos.x>=0&&shadowPos.y<=1&&shadowPos.y>=0&&shadowDepth<0.9999&&distanceFromEye<shadowEnd)
		{
			oneMinusShadowStrength=1;
			if(texture(texture_depth_shadow, shadowPos.xy).r>shadowPos.z-shadowBias)
					oneMinusShadowStrength=0;//ez a shadow strength egyelore, hogy segitsen az elhalvanyulas kiszamolasaban

			if(distanceFromEye>shadowStart)
				oneMinusShadowStrength*=(shadowEnd-distanceFromEye)*shadowHelper;

			oneMinusShadowStrength=1-oneMinusShadowStrength;
		}
	}
    diffuse*=0.8*oneMinusShadowStrength+0.2;
    specular*=oneMinusShadowStrength;

    //add sun beleuchtung to the sum
    lighting_sum+=ambient+diffuse+specular;

    //point lights
    //...

    //fresnel
    float fresnel=max(dot(normal, viewDirection),0);
    vec3 endColour=mix(lighting_sum, ambient,fresnel*(1-min(5*depth,1)));

    //fog
    float alpha=min(5*depth, 1);
    if(distanceFromEye>fogStart)
        alpha*=(fogEnd-distanceFromEye)*fogHelper;
    if(alpha<0)
        alpha=0;

    fragColour=vec4(lighting_sum, alpha);
}

float linearizeDepth(float depth) 
{
    float z = depth * 2.0 - 1.0; // back to NDC 
    return (2.0 * projectionNear * projectionFar) / (projectionFar + projectionNear - z * (projectionFar - projectionNear));
}
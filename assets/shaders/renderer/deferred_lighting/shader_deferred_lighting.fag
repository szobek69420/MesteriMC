#version 330 core

out vec4 fragColor;

in vec3 lightPosition;
in vec3 lightColour;
in vec3 lightAttenuation;

uniform sampler2D texture_normal;
uniform sampler2D texture_albedospec;
uniform sampler2D texture_shadow;
uniform sampler2D texture_depth;
uniform sampler2D texture_ssao;

uniform int shadowOn;
uniform mat4 shadow_lightMatrix; //from the camera's view space to the light's projection space
const float shadowBias=0.003;
const vec2 shadowSampleOffsets[9]=vec2[9](
	vec2(-0.00005, -0.00005),
	vec2(-0.00005, 0),
	vec2(-0.00005, 0.00005),
	vec2(0, -0.00005),
	vec2(0, 0),
	vec2(0, 0.00005),
	vec2(0.00005, -0.00005),
	vec2(0.00005, 0),
	vec2(0.00005, 0.00005)
);
const float shadowSampleStrength[9]=float[9](
	0.05,
	0.12,
	0.05,
	0.12,
	0.32,
	0.12,
	0.05,
	0.12,
	0.05
);

uniform mat4 projection_inverse;

uniform float onePerScreenWidth;
uniform float onePerScreenHeight;

uniform float fogStart;
uniform float fogEnd;
uniform float fogHelper;//1/(fogEnd-fogStart)

void main()
{
	int isDirectional=0;
	if(lightAttenuation.y<0.00001&&lightAttenuation.z<0.00001)
		isDirectional=69;

	vec2 uv=vec2(gl_FragCoord.x*onePerScreenWidth, gl_FragCoord.y*onePerScreenHeight);
	float depth=texture(texture_depth, uv).r;//getting depth buffer info
	vec4 pos = projection_inverse * (vec4(uv, depth, 1)* 2 - 1);
	vec3 viewspace_position = pos.xyz / pos.w;
    vec3 view_dir = normalize(-viewspace_position); //(view_pos-frag_pos), but view_pos is (0, 0, 0) in view space
	
	vec3 normal = texture(texture_normal, uv).rgb * 2 - 1;
	vec3 albedo = texture(texture_albedospec, uv).rgb;
	float specular = texture(texture_albedospec, uv).a;
    //float ambientOcclusion = texture(texture_ssao, uv).r;
	float ambientOcclusion=1;
	
	// attenuation
	float distance = length(lightPosition - viewspace_position);
	float attenuation = lightAttenuation.x;
	if(isDirectional==0)
		attenuation=lightAttenuation.x / (1 + lightAttenuation.y * distance + lightAttenuation.z * distance * distance);

	vec3 lighting = vec3(0);
	
	// ambient
	vec3 amb = 0.3*attenuation*ambientOcclusion*albedo;

	// albedo
	vec3 light_dir;
	if(isDirectional!=0)//directional
		light_dir=lightPosition;
	else
		light_dir=normalize(lightPosition - viewspace_position);

	vec3 alb = max(dot(normal, light_dir), 0.0) * albedo * lightColour;

	// specular
	vec3 halfway_dir = normalize(light_dir + view_dir);  
	float sp = pow(max(dot(normal, halfway_dir), 0.0), 16.0);
	vec3 spec = lightColour * sp * specular;

	//shadow check
	float oneMinusShadowStrength=1;
	if(shadowOn!=0)
	{
		vec4 shadowPos=shadow_lightMatrix*vec4(viewspace_position, 1);
		shadowPos.xyz/=shadowPos.w;
		shadowPos=0.5*shadowPos+0.5;
		float shadowDepth=texture(texture_shadow, shadowPos.xy).r;


		if(shadowPos.x<=1&&shadowPos.x>=0&&shadowPos.y<=1&&shadowPos.y>=0&&shadowDepth<0.9999)
		{
			oneMinusShadowStrength=0;
			if(texture(texture_shadow, shadowPos.xy).r>shadowPos.z-shadowBias)
					oneMinusShadowStrength=1;
		}
	}
	
	alb *= attenuation*oneMinusShadowStrength;
	spec *= attenuation*oneMinusShadowStrength;
	lighting += amb + alb + spec;

	float alpha=1;
	float distanceFromEye=length(viewspace_position);
	if(distanceFromEye>fogStart)
		alpha=(fogEnd-distanceFromEye)*fogHelper;
	if(alpha<0)
		alpha=0;

	fragColor = vec4(lighting,alpha);

	//fragColor = vec4(oneMinusShadowStrength, oneMinusShadowStrength, oneMinusShadowStrength, 1.0);	
	//fragColor = vec4(ambientOcclusion, ambientOcclusion, ambientOcclusion, 1.0);	

	//fragColor=vec4(depth, depth, depth,1);
	//fragColor = vec4(normal, 1.0);
	//fragColor=vec4(0.005*viewspace_position+0.5,1);
}
#version 330 core

struct light {
	vec3 position;
	vec3 color;
    
	float constant; //a tutorialban ez nincs itt, de egyelőre kell nekünk, különben túl gyengék lennének a fények
    float linear;
    float quadratic;
    float radius;
};
const int NR_LIGHTS = 32;

in vec2 uv;
out vec4 fragColor;

uniform sampler2D texture_normal;
uniform sampler2D texture_albedospec;
uniform sampler2D texture_shadow;
uniform sampler2D texture_depth;

uniform mat4 projection_inverse;
uniform light lights[NR_LIGHTS];

void main()
{
	float depth=texture(texture_depth, uv).r;//getting depth buffer info
	vec4 pos = projection_inverse * (vec4(uv, depth, 1)* 2 - 1);
	vec3 viewspace_position = pos.xyz / pos.w;
    vec3 view_dir = normalize(-viewspace_position); //(view_pos-frag_pos), but view_pos is (0, 0, 0) in view space
	
	vec3 normal = texture(texture_normal, uv).rgb * 2 - 1;
	vec3 albedo = texture(texture_albedospec, uv).rgb;
	float specular = texture(texture_albedospec, uv).a;
	
	vec3 lighting = albedo * 0.1; // hard-coded ambient component
	for(int i = 0; i < NR_LIGHTS; ++i)
	{
		// calculate distance between light source and current fragment
        float distance = length(lights[i].position - viewspace_position);
        if(distance < lights[i].radius)
        {
			// albedo
			vec3 light_dir = normalize(lights[i].position - viewspace_position);
			vec3 alb = max(dot(normal, light_dir), 0.0) * albedo * lights[i].color;
			// specular
			vec3 halfway_dir = normalize(light_dir + view_dir);  
			float sp = pow(max(dot(normal, halfway_dir), 0.0), 16.0);
			vec3 spec = lights[i].color * sp * specular;
			// attenuation
			float attenuation = 1.0 / (lights[i].constant + lights[i].linear * distance + lights[i].quadratic * distance * distance);
			alb *= attenuation;
			spec *= attenuation;
			lighting += alb + spec;
		}
	}
	fragColor = pow(vec4(lighting, 1.0), vec4(0.4545));

	//fragColor=vec4(0.005*viewspace_position+0.5,1);
}